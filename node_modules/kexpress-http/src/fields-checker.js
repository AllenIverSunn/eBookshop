const typeCheckers = {
    integer: 'number',
    long: 'number',
    float: 'number',
    double: 'number',
    string: 'string',
    byte: 'string',
    binary: 'string',
    boolean: 'boolean',
    date: 'string',
    dateTime: 'string',
    password: 'string'
};

function checkType(value, typeName) {
    const typeChecker = typeCheckers[typeName];
    if ( typeof typeChecker === 'string' ) {
        return typeof value === typeChecker;
    }
    else if ( typeChecker instanceof Function ) {
        return typeChecker(value);
    }

    return false;
}

const Errors = {
    Missing: 0,
    TypeMismatched: 1,
    UnrecognizedType: 2
};

async function checkFields(value, rules, path) {
    if ( !path ) {
        path = '';
    }

    // Convert the simple rule format(string format) to completed rule(object format).
    if ( typeof rules === 'string' ) {
        rules = {
            type: rules,
            required: false
        };

        // * means the field is required.
        if ( rules.type.endsWith('*') ) {
            // Slice the type name
            rules.type = rules.type.slice(0, -1);
            rules.required = true;
        }
    }

    const required = rules.required;
    // The field is optional and the value is null(not exist)
    if ( !required && value === null ) {
        return [];
    }

    // The field is required and the value is null(not exist)
    if ( value === null ) {
        return [{
            type: Errors.Missing,
            path: path,
            message: '字段值缺失',
        }];
    }
    // The field is not object
    // Check the type of field directly
    else if ( !(value instanceof Object) ) {
        if ( !checkType(value, rules.type) ) {
            return [{
                type: Errors.TypeMismatched,
                path: path,
                message: `字段值类型应该是${rules.type}`
            }];
        }
        
        return [];
    }

    if ( rules.type === 'object' && (typeof value !== 'object' || value instanceof Array) ) {
        return [{
            type: Errors.TypeMismatched,
            path: path,
            message: `字段值类型应该是${rules.type}`
        }];
    }
    // The field is object
    // Check the properties of object
    else if ( rules.type === 'object' ) {
        const properties = rules.properties;
        if ( !properties ) {
            return [];
        }

        const propertyNames = Object.keys(properties);

        let lastErrors = [];
        for ( const propertyName of propertyNames ) {
            const propertyRule = properties[propertyName];
            let propertyValue = value[propertyName];
            if ( propertyValue === undefined ) {
                propertyValue = null;
            }

            let nextPath = `${path}.${propertyName}`;
            if ( path === '' ) {
                nextPath = nextPath.slice(1);
            }

            const newErrors = await checkFields(propertyValue, propertyRule, nextPath);
            lastErrors = lastErrors.concat(newErrors);
        }

        return lastErrors;
    }
    // The field is array
    // Check the items of array
    else if ( rules.type === 'array' && !(value instanceof Array) ) {
        return [{
            type: Errors.TypeMismatched,
            path: path,
            message: `字段值类型应该是${rules.type}`
        }];
    }
    else if ( rules.type === 'array' && value instanceof Array ) {
        const propertyRule = rules.items;
        if ( !propertyRule ) {
            return [];
        }

        let lastErrors = [];
        let itemIndex = 0;
        for ( let item of value ) {
            if ( item === undefined ) {
                item = null;
            }

            const nextPath = `${path}[${itemIndex}]`;

            const newErrors = await checkFields(item, propertyRule, nextPath);
            lastErrors = lastErrors.concat(newErrors);
            itemIndex ++;
        }

        return lastErrors;
    }

    return [{
        type: Errors.UnrecognizedType,
        path: path,
        message: `无法识别的类型：${rules.type}`
    }];
}

module.exports = {
    checkFields
};