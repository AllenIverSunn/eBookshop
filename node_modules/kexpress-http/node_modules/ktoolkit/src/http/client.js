const http = require('http');
const defaultRequester = http.request;
const qs = require('qs');
const uuid = require('uuid');
const promise = require('../core/promise');

class HttpClient {
    constructor() {
        this.headers = {
            Accept: 'text/html,application/xhtml+xml,application/xml;q=0.8',
            'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',
            Connection: 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            Pragma: 'no-cache',
            'Cache-Control': 'no-cache'
        };

        this.cookies = {
        };
    }

    makeHeaders(userHeaders) {
        const headers = {};
        Object.keys(this.headers).forEach(headerName => {
            headers[headerName] = this.headers[headerName];
        });
        if ( userHeaders ) {
            Object.keys(userHeaders).forEach(headerName => {
                headers[headerName] = userHeaders[headerName];
            });
        }

        return headers;
    }

    request(opt) {
        const query = opt.query;
        if ( query ) {
            delete opt.query;
        }

        let data = opt.data;
        if ( data ) {
            delete opt.data;
        }

        if ( query ) {
            opt.path += `?${qs.stringify(query)}`;
        }

        const headers = this.makeHeaders(opt.headers);

        let dataType = opt.dataType;

        if ( data && (data instanceof MultipartEntity) ) {
            dataType = `multipart/form-data; boundary=${data.boundaryKey}`;
            data = data.toBuffer();
        }

        if ( dataType ) {
            headers['Content-Type'] = dataType;
            delete opt.dataType;
        }

        if ( data ) {
            headers['Content-Length'] = data.length;
        }

        const cookies = this.loadCookies(headers);
        headers['Cookie'] = cookies;

        opt.headers = headers;

        let requester = defaultRequester;
        if ( opt.requester ) {
            requester = opt.requester;
            delete opt.requester;
        }

        let timeout = 0;
        if ( opt.timeout ) {
            timeout = opt.timeout;
            delete opt.timeout;
        }

        const requestPromise = promise.promisify(callback => {
            const req = requester(opt, res => {
                if ( res.statusCode ) {
                    if ( res.headers['set-cookie'] ) {
                        this.saveCookies(res.headers['set-cookie']);
                    }
                }

                let body = Buffer.from([]);
                let called = false;
                res.on('data', resData => {
                    body = Buffer.concat([ body, resData ]);
                })
                .on('end', () => {
                    if ( !called ) {
                        called = true;
                        if ( res.statusCode !== 200 ) {
                            const error = {
                                statusCode: res.statusCode,
                                statusMessage: res.statusMessage,
                                message: `${res.statusCode} ${res.statusMessage}`
                            };
                            callback(error, {
                                req: req,
                                res: res
                            });
                        }
                        else {
                            callback(null, {
                                body: body,
                                req: req,
                                res: res
                            });
                        }
                    }
                });
            });

            if ( timeout ) {
                req.setTimeout(timeout);
            }

            if ( data ) {
                req.write(data);
            }

            req.on('error', error => {
                callback(error, {});
            });

            req.end();
        });

        return requestPromise();
    }

    saveCookies(cookies) {
        cookies.forEach(cookieString => {
            const fields = cookieString.split(';').map(str => str.trim());
            const field = fields[0];
            const elements = field.split('=').map(str => str.trim());
            this.cookies[elements[0]] = elements[1];
        });
    }

    loadCookies() {
        return Object.keys(this.cookies).map(cookieName => {
            return `${cookieName}=${this.cookies[cookieName]}`;
        }).join('; ');
    }
}

class MultipartEntity {
    constructor() {
        this._boundaryKey = `---------------${uuid.v4()}`;
        this._parts = [];
    }

    addField(name, value) {
        this._parts.push({
            type: 'field',
            name: name,
            value: value
        });

        return this;
    }

    addFile(name, fileName, fileData, contentType) {
        this._parts.push({
            type: 'file',
            name: name,
            fileName: fileName,
            data: fileData,
            contentType: contentType
        });

        return this;
    }

    get boundaryKey() {
        return this._boundaryKey;
    }

    toBuffer() {
        const buffers = [];

        this._parts.forEach(part => {
            if ( part.type === 'field' ) {
                const field = part;
                const payload = `--${this._boundaryKey}\r\n` +
                    `Content-Disposition: form-data; name="${field.name}"\r\n\r\n` +
                    `${field.value}\r\n`;

                buffers.push(Buffer.from(payload));
            }
            else if ( part.type === 'file' ) {
                const file = part;

                const payload = `--${this._boundaryKey}\r\n` +
                    `Content-Disposition: form-data; name="${file.name}"; filename="${file.fileName}"\r\n` +
                    `Content-Type: ${file.contentType}\r\n\r\n`;

                buffers.push(Buffer.from(payload));
                buffers.push(file.data);
                buffers.push(Buffer.from('\r\n'));
            }
        });

        const endData = Buffer.from(`--${this._boundaryKey}--\r\n\r\n`);
        buffers.push(endData);

        return Buffer.concat(buffers);
    }
}

HttpClient.MultipartEntity = MultipartEntity;

module.exports = {
    HttpClient
};
